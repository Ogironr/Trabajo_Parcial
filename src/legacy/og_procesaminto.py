# -*- coding: utf-8 -*-
"""Copia de TRABAJO_PARCIAL

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QcXemUPfE0_hpLgG6t_8rsuTmpC4Gpmf

# Importacion de paquetes
"""

# Importacion de librerias
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pandas_profiling import ProfileReport
from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder, StandardScaler, LabelEncoder, PowerTransformer
from sklearn.impute import KNNImputer
from sklearn.metrics import accuracy_score
from sklearn.metrics import roc_auc_score
from sklearn.metrics import roc_curve
from imblearn.over_sampling import SMOTE
import xgboost as xgb

from sklearn.ensemble import BaggingClassifier
from sklearn.tree import DecisionTreeClassifier

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix

"""# Importar dataset"""

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/MAESTRIA/CICLO 4/REDES NEURONALES/train_infarto.csv',sep = ';', encoding='latin-1')


"""# FEATURE ENGINEERING"""

drop = ['KFK_BLOOD']

ohe = ['FK_STENOK','IBS_POST','GB','ant_im','lat_im','inf_im','post_im']

ordinal= ['INF_ANAM','STENOK_AN','DLIT_AG','ZSN_A','TIME_B_S','R_AB_1_n','R_AB_2_n','R_AB_3_n','NA_R_1_n','NA_R_2_n','NA_R_3_n','NOT_NA_1_n','NOT_NA_2_n','NOT_NA_3_n']

boxcox = ['S_AD_KBRIG','D_AD_KBRIG','S_AD_ORIT','D_AD_ORIT','K_BLOOD','NA_BLOOD','ALT_BLOOD','AST_BLOOD','L_BLOOD','ROE']

sin_cambios = ['AGE','SEX','IBS_NASL','SIM_GIPERT','nr_11','nr_01','nr_02','nr_03','nr_04','nr_07','nr_08','np_01','np_04','np_05','np_07','np_08','np_09','np_10',
               'endocr_01','endocr_02','endocr_03','zab_leg_01','zab_leg_02','zab_leg_03','zab_leg_04', 'zab_leg_06','O_L_POST','K_SH_POST','MP_TP_POST','SVT_POST','GT_POST',
               'FIB_G_POST','IM_PG_P','ritm_ecg_p_01','ritm_ecg_p_02','ritm_ecg_p_04','ritm_ecg_p_06','ritm_ecg_p_07','ritm_ecg_p_08','n_r_ecg_p_01','n_r_ecg_p_02',
               'n_r_ecg_p_03','n_r_ecg_p_04','n_r_ecg_p_05','n_r_ecg_p_06','n_r_ecg_p_08','n_r_ecg_p_09','n_r_ecg_p_10','n_p_ecg_p_01','n_p_ecg_p_03','n_p_ecg_p_04',
               'n_p_ecg_p_05','n_p_ecg_p_06','n_p_ecg_p_07','n_p_ecg_p_08','n_p_ecg_p_09','n_p_ecg_p_10','n_p_ecg_p_11','n_p_ecg_p_12','fibr_ter_01',
               'fibr_ter_02','fibr_ter_03','fibr_ter_05','fibr_ter_06','fibr_ter_07','fibr_ter_08','GIPO_K','GIPER_NA','NA_KB','NOT_NA_KB','LID_KB','NITR_S',
               'LID_S_n','B_BLOK_S_n','ANT_CA_S_n','GEPAR_S_n','ASP_S_n','TIKL_S_n','TRENT_S_n']

target = ['ZSN']

"""## KNN IMPUTER"""

!pip install scikit-learn

from sklearn.impute import KNNImputer

df = df.drop(columns=drop)

columnas_para_imputar = ohe + ordinal + boxcox + sin_cambios
df_imputacion = df[columnas_para_imputar].copy()

imputer = KNNImputer(n_neighbors=3, weights="uniform")  # puedes probar también con 'distance'
df_imputado = pd.DataFrame(imputer.fit_transform(df_imputacion), columns=columnas_para_imputar)

# Insertar nuevamente las columnas drop y target (si las necesitas luego)
df_final = pd.concat([df[['ID']  + target], df_imputado], axis=1)

df_final.isnull().values.any()

"""## OHE - BOX COX"""

ohe = ['FK_STENOK','IBS_POST','GB','ant_im','lat_im','inf_im','post_im']

boxcox = ['S_AD_KBRIG','D_AD_KBRIG','S_AD_ORIT','D_AD_ORIT','K_BLOOD','NA_BLOOD','ALT_BLOOD','AST_BLOOD','L_BLOOD','ROE']

# El resto de las columnas las puedes dejar pasar sin transformación (passthrough)
otras_columnas = [col for col in df.columns if col not in ohe + boxcox + drop + target]

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder, PowerTransformer
from sklearn.pipeline import Pipeline
import pandas as pd

# Definir el ColumnTransformer
preprocessor = ColumnTransformer(
    transformers=[
        ('ohe', OneHotEncoder(drop='first', handle_unknown='ignore'), ohe),
        ('boxcox', PowerTransformer(method='yeo-johnson'), boxcox),
        ('passthrough', 'passthrough', otras_columnas)
    ]
)

df_transformed = preprocessor.fit_transform(df)

# Obtener nombres de columnas transformadas por OHE
ohe_feature_names = preprocessor.named_transformers_['ohe'].get_feature_names_out(ohe)

# Combinar con el resto de columnas
columnas_finales = list(ohe_feature_names) + boxcox + otras_columnas

# Convertir a DataFrame
df_final = pd.DataFrame(df_transformed, columns=columnas_finales)

df_final.head()

"""## CONSTRUCCION VARIABLES"""

# Crear variable que representa la cantidad de problemas pulmonares
df_final['PULMONARY_ISSUES_COUNT'] = df_final[['zab_leg_01', 'zab_leg_02', 'zab_leg_03', 'zab_leg_04', 'zab_leg_06']].sum(axis=1)

df_final.drop(columns=['zab_leg_01', 'zab_leg_02', 'zab_leg_03', 'zab_leg_04', 'zab_leg_06'], inplace=True)

# Crear variable que representa la cantidad de problemas endocrinos (diabetes)
df_final['DIABETES_ISSUES_COUNT'] = df_final[['endocr_01', 'endocr_02', 'endocr_03']].sum(axis=1)

df_final.drop(columns=['endocr_01', 'endocr_02', 'endocr_03'], inplace=True)

neuro_vars = [
    'nr_11', 'nr_01', 'nr_02', 'nr_03', 'nr_04', 'nr_07', 'nr_08',
    'np_01', 'np_04', 'np_05', 'np_07', 'np_08', 'np_09', 'np_10'
]

df_final['NEURO_ISSUES_COUNT'] = df_final[neuro_vars].sum(axis=1)

df_final.drop(columns=neuro_vars, inplace=True)

df_final['target'] = df['ZSN']

df_final.to_csv('/content/drive/MyDrive/MAESTRIA/CICLO 4/REDES NEURONALES/df_balanced.csv', index=False)

"""# DATA COMPETENCIA"""

df = pd.read_csv('/content/drive/MyDrive/MAESTRIA/CICLO 4/REDES NEURONALES/test_infarto.csv',sep = ';', encoding='latin-1')

drop = ['KFK_BLOOD']

ohe = ['FK_STENOK','IBS_POST','GB','ant_im','lat_im','inf_im','post_im']

ordinal= ['INF_ANAM','STENOK_AN','DLIT_AG','ZSN_A','TIME_B_S','R_AB_1_n','R_AB_2_n','R_AB_3_n','NA_R_1_n','NA_R_2_n','NA_R_3_n','NOT_NA_1_n','NOT_NA_2_n','NOT_NA_3_n']

boxcox = ['S_AD_KBRIG','D_AD_KBRIG','S_AD_ORIT','D_AD_ORIT','K_BLOOD','NA_BLOOD','ALT_BLOOD','AST_BLOOD','L_BLOOD','ROE']

sin_cambios = ['AGE','SEX','IBS_NASL','SIM_GIPERT','nr_11','nr_01','nr_02','nr_03','nr_04','nr_07','nr_08','np_01','np_04','np_05','np_07','np_08','np_09','np_10',
               'endocr_01','endocr_02','endocr_03','zab_leg_01','zab_leg_02','zab_leg_03','zab_leg_04', 'zab_leg_06','O_L_POST','K_SH_POST','MP_TP_POST','SVT_POST','GT_POST',
               'FIB_G_POST','IM_PG_P','ritm_ecg_p_01','ritm_ecg_p_02','ritm_ecg_p_04','ritm_ecg_p_06','ritm_ecg_p_07','ritm_ecg_p_08','n_r_ecg_p_01','n_r_ecg_p_02',
               'n_r_ecg_p_03','n_r_ecg_p_04','n_r_ecg_p_05','n_r_ecg_p_06','n_r_ecg_p_08','n_r_ecg_p_09','n_r_ecg_p_10','n_p_ecg_p_01','n_p_ecg_p_03','n_p_ecg_p_04',
               'n_p_ecg_p_05','n_p_ecg_p_06','n_p_ecg_p_07','n_p_ecg_p_08','n_p_ecg_p_09','n_p_ecg_p_10','n_p_ecg_p_11','n_p_ecg_p_12','fibr_ter_01',
               'fibr_ter_02','fibr_ter_03','fibr_ter_05','fibr_ter_06','fibr_ter_07','fibr_ter_08','GIPO_K','GIPER_NA','NA_KB','NOT_NA_KB','LID_KB','NITR_S',
               'LID_S_n','B_BLOK_S_n','ANT_CA_S_n','GEPAR_S_n','ASP_S_n','TIKL_S_n','TRENT_S_n']

"""## KNN IMPUTER"""

!pip install scikit-learn

from sklearn.impute import KNNImputer

df = df.drop(columns=drop)

columnas_para_imputar = ohe + ordinal + boxcox + sin_cambios
df_imputacion = df[columnas_para_imputar].copy()

imputer = KNNImputer(n_neighbors=3, weights="uniform")  # puedes probar también con 'distance'
df_imputado = pd.DataFrame(imputer.fit_transform(df_imputacion), columns=columnas_para_imputar)

# Insertar nuevamente las columnas drop y target (si las necesitas luego)
df_final = pd.concat([df[['ID']], df_imputado], axis=1)

df_final.isnull().values.any()

"""## OHE - BOX COX"""

ohe = ['FK_STENOK','IBS_POST','GB','ant_im','lat_im','inf_im','post_im']

boxcox = ['S_AD_KBRIG','D_AD_KBRIG','S_AD_ORIT','D_AD_ORIT','K_BLOOD','NA_BLOOD','ALT_BLOOD','AST_BLOOD','L_BLOOD','ROE']

# El resto de las columnas las puedes dejar pasar sin transformación (passthrough)
otras_columnas = [col for col in df.columns if col not in ohe + boxcox + drop]

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder, PowerTransformer
from sklearn.pipeline import Pipeline
import pandas as pd

# Definir el ColumnTransformer
preprocessor = ColumnTransformer(
    transformers=[
        ('ohe', OneHotEncoder(drop='first', handle_unknown='ignore'), ohe),
        ('boxcox', PowerTransformer(method='yeo-johnson'), boxcox),
        ('passthrough', 'passthrough', otras_columnas)
    ]
)

df_transformed = preprocessor.fit_transform(df)

# Obtener nombres de columnas transformadas por OHE
ohe_feature_names = preprocessor.named_transformers_['ohe'].get_feature_names_out(ohe)

# Combinar con el resto de columnas
columnas_finales = list(ohe_feature_names) + boxcox + otras_columnas

# Convertir a DataFrame
df_final = pd.DataFrame(df_transformed, columns=columnas_finales)

df_final.head()

"""## CONSTRUCCION VARIABLES"""

# Crear variable que representa la cantidad de problemas pulmonares
df_final['PULMONARY_ISSUES_COUNT'] = df_final[['zab_leg_01', 'zab_leg_02', 'zab_leg_03', 'zab_leg_04', 'zab_leg_06']].sum(axis=1)

df_final.drop(columns=['zab_leg_01', 'zab_leg_02', 'zab_leg_03', 'zab_leg_04', 'zab_leg_06'], inplace=True)

# Crear variable que representa la cantidad de problemas endocrinos (diabetes)
df_final['DIABETES_ISSUES_COUNT'] = df_final[['endocr_01', 'endocr_02', 'endocr_03']].sum(axis=1)

df_final.drop(columns=['endocr_01', 'endocr_02', 'endocr_03'], inplace=True)

neuro_vars = [
    'nr_11', 'nr_01', 'nr_02', 'nr_03', 'nr_04', 'nr_07', 'nr_08',
    'np_01', 'np_04', 'np_05', 'np_07', 'np_08', 'np_09', 'np_10'
]

df_final['NEURO_ISSUES_COUNT'] = df_final[neuro_vars].sum(axis=1)

df_final.drop(columns=neuro_vars, inplace=True)

"""## UNDER SAMPLING"""

df_final.to_csv('/content/drive/MyDrive/MAESTRIA/CICLO 4/REDES NEURONALES/df_test_balanced.csv', index=False)